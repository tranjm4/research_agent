"""
File: src/backend/agent/models/verifier_model.py

This file defines the verifier model for the LangGraph agent.
It includes the logic for verifying plans generated by the planner.

It receives a plan and context, and returns a verification result.
"""

from langchain.chat_models import init_chat_model
from langchain_core.messages import ChatMessage, ToolMessage, HumanMessage, AIMessage, SystemMessage
from utils.models import ModelWrapper
from typing import Dict, Any, Optional, Union
from typing_extensions import TypedDict

from utils.graph import PlanState
from utils.typing import ModelConfig

from ast import literal_eval

class VerifierModel(ModelWrapper):
    default_system_prompt = """
    You are a verifier within a research assistant system.
    Your task is to verify the plans generated by the planner.
    You will receive a plan and context, and you must determine if the plan is valid and feasible.
    If the plan is valid, return "verified". If not, return "not verified".
    
    If the plan is not verified, provide a brief explanation of why it is not valid.
    """

    def __init__(self, config: ModelConfig):
        """
        Initializes the VerifierModel with the given configuration.
        
        Args:
            config (Optional[Dict[str, Any]]): Configuration for the verifier model.
        """
        self.model_params = config.get("params", {})
        self.metadata = config.get("metadata", {})
        self.logging = config.get("logging", {})
        super().__init__(self.model_params, self.metadata, self.logging)
        
        self.system_prompt = config.get("system_prompt", VerifierModel.default_system_prompt)
        
        self.system_message = SystemMessage(content=self.system_prompt)
        self.model = init_chat_model(**self.model_params)
        
        
    def verify(self, plan: str, context: str) -> str:
        response = self.model.invoke(
            [
                self.system_message,
                HumanMessage(content=f"Plan: {plan}\nContext: {context}"),
            ]
        )
        
        if isinstance(response, AIMessage):
            return self._parse_response(response)
        else:
            raise ValueError("Unexpected response type from the model. Expected AIMessage.")
        
    def _parse_response(self, response: AIMessage) -> Dict[str, str]:
        """ Parses the response from the verifier model.
        
        Expected response format: {"verified": "yes" or "no", "feedback": "explanation" or empty string}
        Args:
            response (AIMessage): The response from the verifier model.
            
        Returns:
            Dict[str, str]: A dictionary containing the verification status and feedback.
        """
        content = response.content.strip()
        if content:
            try:
                parsed_content = literal_eval(content)
                if isinstance(parsed_content, dict) and "verified" in parsed_content:
                    is_verified = parsed_content["verified"].lower() in ["yes", "true", "1"]
                    if is_verified:
                        return {
                            "verified": True,
                            "feedback": ""
                        }
                    else:
                        # If not verified, ensure feedback is present
                        if parsed_content.get("feedback", ""):
                            return {
                                "verified": False,
                                "feedback": parsed_content["feedback"]
                            }
                        else:
                            # If feedback is not provided, raise an error
                            raise ValueError("Feedback is required when the plan is not verified.")
                else:
                    raise ValueError("Response does not contain 'verified' key or is not a dictionary.")
            except (SyntaxError, ValueError):
                raise ValueError("Response could not be parsed as a dictionary.")
        else:
            raise ValueError("Empty response from the verifier model.")
        

    def node(self, state: PlanState) -> Dict[str, Any]:
        """
        Node function for the verifier model.
        
        Args:
            state (PlanState): The current state containing the plan and context.

        Returns:
            Dict[str, Any]: The verification result, either "verified" or "not verified".
        """
        plan = state["plan"]
        context = state["context"]
        verification_response = self.verify(plan, context)
        is_verified = verification_response["verified"]
        feedback = verification_response.get("feedback", "")
        
        # Update the context with the context
        state_updates = {
            "context": state["context"] + [f"Plan: {plan}"],
            "verified": is_verified,
            "feedback": feedback
        }
        
        return state_updates
